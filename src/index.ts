/**
 * An operator definition is a collection of structures with the following
 * elements:
 *
 * element | .
 * -- | --
 * *func*     | Operator implementation
 * *arity*    | Number of arguments
 * *priority* | Order of operations, higher priority is better
 */
export type OperatorDefinition = {
  [operator: string]: {
    func: (...args: string[]) => string;
    arity: number;
    priority: number;
  };
};

/**
 * Converts infix expressions to reverse Polish notation using the shunting
 * yard algorithm.
 * @param operatorDefinition Operator definition so we can prioritize operators
 * @param tokens Tokens to convert to reverse Polish notation
 */
export const shuntingYard = (operatorDefinition: OperatorDefinition) => (
  tokens: string[]
) => {
  const { outputStack, operatorStack } = tokens.reduce(
    (
      {
        outputStack,
        operatorStack
      }: { outputStack: string[]; operatorStack: string[] },
      token
    ) => {
      if (token === "(") {
        operatorStack.push(token);
      } else if (token === ")") {
        while (
          operatorStack.length &&
          operatorStack[operatorStack.length - 1] !== "("
        ) {
          outputStack.push(operatorStack.pop() as string);
        }

        if (
          operatorStack.length &&
          operatorStack[operatorStack.length - 1] === "("
        ) {
          operatorStack.pop();
        } else {
          throw Error("Parens mismatch");
        }
      } else if (operatorDefinition[token] !== undefined) {
        while (
          operatorStack.length &&
          operatorDefinition[operatorStack[operatorStack.length - 1]] !==
            undefined &&
          operatorDefinition[operatorStack[operatorStack.length - 1]]
            .priority >= operatorDefinition[token].priority
        ) {
          outputStack.push(operatorStack.pop() as string);
        }

        operatorStack.push(token);
      } else {
        outputStack.push(token);
      }

      return {
        outputStack,
        operatorStack
      };
    },
    { outputStack: [], operatorStack: [] }
  );

  while (operatorStack.length) {
    const operator = operatorStack[operatorStack.length - 1];
    if (operator !== "(") {
      outputStack.push(operatorStack.pop() as string);
    } else {
      throw Error("Parens mismatch");
    }
  }

  return outputStack;
};

/**
 * Given a reverse Polish notation generated by `shuntingYard` or some other
 * method, calculate one final result given a operator definition.
 * @param operatorDefinition Definition to execute with respect to
 * @param tokens Tokens to execute in reverse Polish notation
 */
export const evaluateRPN = (operatorDefinition: OperatorDefinition) => (
  tokens: string[]
) =>
  tokens.reduce((stack: string[], token) => {
    if (operatorDefinition[token] !== undefined) {
      const operator = operatorDefinition[token];
      const parameters: string[] = [];
      for (let i = 0; i < operator.arity; i++) {
        parameters.push(stack.pop() as string);
      }
      stack.push(operator.func(...parameters.reverse()));
    } else {
      stack.push(token);
    }

    return stack;
  }, [])[0];

/**
 * Utility function to aid in debugging expressions and operator definitions.
 * @param operatorDefinition Definition to trace with debug statements
 * @param tracer Serializer to run for each debug trace
 */
export const traceDebugOperations = (
  operatorDefinition: OperatorDefinition,
  {
    tracer,
    getDebugLog
  }: {
    tracer: ({
      operator,
      parameters,
      result
    }: {
      operator: string;
      parameters: string[];
      result: string;
    }) => void;
    getDebugLog: () => string[];
  } = (() => {
    const closureLog: string[] = [];
    return {
      tracer: ({
        operator,
        parameters: [x, y],
        result
      }: {
        operator: string;
        parameters: [string, string];
        result: string;
      }) => {
        closureLog.push(`${x} ${operator} ${y} = ${result}`);
      },
      getDebugLog: () => closureLog
    } as any;
  })()
) => {
  const tracedDefinition: OperatorDefinition = {};
  for (const operator in operatorDefinition) {
    const operation = operatorDefinition[operator];
    tracedDefinition[operator] = {
      ...operation,
      func: (...parameters) => {
        const result = operation.func(...parameters);
        tracer({ operator, parameters, result });
        return result;
      }
    };
  }

  return { tracedDefinition, getDebugLog };
};
